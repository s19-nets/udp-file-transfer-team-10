from ast import literal_eval
from sys import argv, exit
from uuid import uuid4
from enum import Enum
from socket import socket, AF_INET, SOCK_DGRAM
from select import select

class State(Enum):
    READY = 0
    WAITING = 1 
    EXITING = 2

def usage():
    print("usage: %s [--server host:port] <filename>"  % sys.argv[0])
    exit(1)

server_addr = ('localhost', 50001)    

MAX_TRIES = 5
last_ack_block = 0
state = State.READY
client_socket = socket(AF_INET, SOCK_DGRAM)
id = uuid4().hex
request = 'put'

fname = "message"
f = open(fname, 'r')

# map socket to function to call when socket is....
read_sockfunc = {}      # ready for reading
write_sockfunc = {}     # ready for writing
error_sockfunc = {}     # broken

def put(block):
    return 0

def get(block):
    return 0

read_sockfunc[client_socket] = put

def send_message():
    if request == 'get': get()
    else: put()

def process_request(sock, request):
    global fname, id, state, last_ack_block
             
    if state == State.READY:
        if retry == True:
            message = str({'request':request, 'fname':fname, 'id':id})
            client_socket.sendto(message.encode(), server_addr)
        else:
            state = State.WAITING
            send_message()
    elif state == State.WAITING:
        if retry == True:
            send_message()
        else:
            message, server_addr = sock.recvfrom(100)
            print("from %s: rec'd '%s'" % (repr(clientAddrPort), message))
            msg_map = literal_eval(message)    # expects a string dictionary as message

def print_error():
    print("error: unavailable to transfer the file")
    exit(1)
 
timeout = 2
tries = 0
while 1:
    read_rdyset, write_rdyset, err_rdyset = select(list(read_sockfunc.keys()),
                                                   list(write_sockfunc.keys()), 
                                                   list(error_sockfunc.keys()),
                                                   timeout)
    if not read_rdyset and not write_rdyset and not err_rdyset:
        print("retry")
        if tries == MAX_TRIES: print_error()
        else: tries += 1
        process_request(None, request, True)
    else:
        tries = 0
        for sock in read_rdyset:
            read_sockfunc[sock](None, request, False)


